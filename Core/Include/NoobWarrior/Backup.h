/*
 * Copyright (C) 2026 Hattozo
 *
 * This file is part of noobWarrior.
 *
 * noobWarrior is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * noobWarrior is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with noobWarrior; if not, see
 * <https://www.gnu.org/licenses/>.
 */
// === noobWarrior ===
// File: Backup.h
// Started by: Hattozo
// Started on: 12/23/2025
// Description: Contains structs and other functions involving backing up Roblox items
#pragma once
#include <NoobWarrior/Database/Database.h>
#include <cstdint>
#include <string>
#include <functional>

namespace NoobWarrior {
class Core;
namespace Backup {
enum class Response {
    Failed,
    Ok, // Not a success yet, we are just getting started.
    UrlNotSet,
    AccountRequired,
    UnsupportedItemType
};

enum class State {
    Failed,
    Success,
    Finalizing,
    DownloadingFile,
    ParsingFile,
    CompressingFile,
    ScrapingMetadata,
    AddingToDatabase,
};

enum class ItemSource {
    OnlineItem,
    LocalFile
};

enum class OnlineItemType {
    Asset,
    Badge,
    Bundle,
    DevProduct,
    Group,
    Pass,
    Universe,
    User
};

// A node representation of an item on the Roblox platform.
struct ItemDescriptor {
    OnlineItemType Type;
    int64_t Id;
    int Version;

    ItemDescriptor* Parent { nullptr };

    uint64_t ChildrenSize;
    ItemDescriptor** Children;

    // These will be populated when they are discovered through API scraping.
    char* Name;

    uint64_t IconSize;
    unsigned char* IconData;
};

ItemDescriptor* ItemDescriptor_New();
void ItemDescriptor_Destroy(ItemDescriptor*);
void ItemDescriptor_AddChild(ItemDescriptor* parent, ItemDescriptor* child);
void ItemDescriptor_RemoveChild(ItemDescriptor* parent, ItemDescriptor* child);
ItemDescriptor** ItemDescriptor_GetChildren(ItemDescriptor* parent, int* size = nullptr);

typedef void* Destination;
enum class DestinationType {
    FileSystem,
    Database
};

struct ProcessOptions {
    ItemSource TargetType;
    OnlineItemType TargetItemType;
    int64_t TargetId;

    DestinationType DestinationType;

    // If DestinationType is Database, then this should be a pointer to a Database.
    // If DestinationType is FileSystem, this should be a pointer to a null-terminated C string that describes the path of the output directory.
    Destination Destination { nullptr };

    bool ParseFilesAndBackupFoundAssets;
    bool DownloadMetadata;
    bool DownloadAutoGeneratedThumbnails;

    std::function<void(State, std::string, size_t, size_t)> Callback;
};

struct Process {
    Core*           Core { nullptr };
    ItemDescriptor* Root { nullptr };
    ProcessOptions* Options { nullptr };

    DestinationType DestinationType;
    Destination Destination;

    double Progress;
};

Process* AllocateProcess(NoobWarrior::Core* core, ProcessOptions);
void DestroyProcess(Process* proc);
Response StartProcess(Process* proc);
}
}