// === noobWarrior ===
// File: Backup.h
// Started by: Hattozo
// Started on: 12/23/2025
// Description: Contains structs and other functions involving backing up Roblox items
#pragma once
#include <NoobWarrior/Database/Database.h>
#include <cstdint>
#include <string>
#include <functional>

namespace NoobWarrior {
class Core;
namespace Backup {
enum class Response {
    Failed,
    Ok, // Not a success yet, we are just getting started.
    UrlNotSet,
    AccountRequired,
    UnsupportedItemType
};

enum class State {
    Failed,
    Success,
    Finalizing,
    DownloadingFile,
    ParsingFile,
    CompressingFile,
    ScrapingMetadata,
    AddingToDatabase,
};

enum class ItemDescriptorType {
    Asset,
    Badge,
    Bundle,
    DevProduct,
    Group,
    Pass,
    Universe,
    User
};

struct ItemDescriptor {
    ItemDescriptorType Type;
    int64_t Id;
    int Version;
    ItemDescriptor* Parent;
    ItemDescriptor* Children;
};

ItemDescriptor* NewItemDescriptor();
void DestroyItemDescriptor(ItemDescriptor*);

enum class TargetType {
    OnlineItem,
    LocalFile
};

typedef void* Destination;
enum class DestinationType {
    FileSystem,
    Database
};

struct ProcessOptions {
    TargetType TargetType;
    ItemDescriptorType TargetItemType;
    int64_t TargetId;

    DestinationType DestinationType;

    // If DestinationType is Database, then this should be a pointer to a Database.
    // If DestinationType is FileSystem, this should be a pointer to a null-terminated C string that describes the path of the output directory.
    Destination Destination { nullptr };

    bool ParseFilesAndBackupFoundAssets;
    bool DownloadMetadata;
    bool DownloadAutoGeneratedThumbnails;

    std::function<void(State, std::string, size_t, size_t)> Callback;
};

struct Process {
    ItemDescriptor* Root;
    ProcessOptions* Options;

    DestinationType DestinationType;
    Destination Destination;

    double Progress;
};

Process* CreateProcess(NoobWarrior::Core* core, ProcessOptions);
void DestroyProcess(Process* proc);
Response StartProcess(Process* proc);
}
}